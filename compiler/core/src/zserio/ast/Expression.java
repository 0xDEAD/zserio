package zserio.ast;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import antlr.RecognitionException;

import zserio.antlr.ZserioParserTokenTypes;
import zserio.antlr.ExpressionEvaluator;
import zserio.antlr.util.ParserException;
import zserio.tools.HashUtil;
import zserio.tools.StringJoinUtil;

public class Expression extends TokenAST
{
    @Override
    public boolean equals(Object other)
    {
        if (!(other instanceof Expression))
            return false;

        return equals((Expression)other);
    }

    @Override
    public int hashCode()
    {
        int hash = HashUtil.HASH_SEED;
        hash = HashUtil.hash(hash, getText());
        final Expression op1 = op1();
        if (op1 != null)
        {
            hash = HashUtil.hash(hash, op1);
            final Expression op2 = op2();
            if (op2 != null)
            {
                hash = HashUtil.hash(hash, op2);
                final Expression op3 = op3();
                if (op3 != null)
                    hash = HashUtil.hash(hash, op3);
            }
        }

        return hash;
    }

    /**
     * Indicates whether some other object is equal to this one.
     *
     * Please note that this method is necessary to hide method equals(AST t) from base class BaseAST.
     * Otherwise equals(expression) will call BaseAST.equals((AST)expression) instead of
     * Expression.equals((Object)expression).
     *
     * @param other The object with which to compare.
     *
     * @return true if this object is the same as given object, otherwise false.
     */
    public boolean equals(Expression other)
    {
        if (this != other)
        {
            if ( !(getText().equals(other.getText())) )
                return false;

            final Expression op1 = op1();
            if (op1 != null)
            {
                if (!op1.equals(other.op1()))
                    return false;

                final Expression op2 = op2();
                if (op2 != null)
                {
                    if (!op2.equals(other.op2()))
                        return false;

                    final Expression op3 = op3();
                    final boolean op3Equals = (op3 != null) ? op3.equals(other.op3()) : (other.op3() == null);
                    if (!op3Equals)
                        return false;
                }
                else
                {
                    if (other.op2() != null)
                        return false;
                }
            }
            else
            {
                if (other.op1() != null)
                    return false;
            }
        }

        return true;
    }

    /**
     * Sets the lexical scope for ID evaluation for the expression.
     *
     * This method is called from code generated by ANTLR (TypeEvaluator.g) and by ChoiceType.
     *
     * @param scope Scope to set.
     */
    public void setScope(Scope scope)
    {
        this.scope = scope;
    }

    /**
     * Sets symbols available in current context.
     *
     * This method is called from code generated by ANTLR (TypeEvaluator.g)
     *
     * @param availableSymbols Set of symbols visible in current context.
     */
    public void setAvailableSymbols(Set<String> availableSymbols)
    {
        this.availableSymbols = availableSymbols;

        // set on all children
        Expression op1 = op1();
        if (op1 != null)
        {
            op1.setAvailableSymbols(availableSymbols);
            Expression op2 = op2();
            if (op2 != null)
            {
                op2.setAvailableSymbols(availableSymbols);
                Expression op3 = op3();
                if (op3 != null)
                    op3.setAvailableSymbols(availableSymbols);
            }
        }
    }

    public void setAllowIndex(boolean allowIndex)
    {
        this.allowIndex = allowIndex;
    }

    /**
     * Gets the lexical scope for the expression.
     *
     * @return Returns lexical scope for the expression.
     */
    public Scope getScope()
    {
        return scope;
    }

    /**
     * Defines evaluated type of the expression.
     */
    public enum ExpressionType
    {
        /** Unknown expression. Used during evaluation only. Method getExprType() never returns this value. */
        UNKNOWN,

        /**
         * Integer expression. Result of expression can be read using getIntegerValue(). Actually, integer
         * result is needed to evaluate const types and length of bit field types.
         */
        INTEGER,

        /** Float expression. Result of expression is not available. */
        FLOAT,

        /** String expression. */
        STRING,

        /** Boolean expression. */
        BOOLEAN,

        /** Expression which result is enumeration type. */
        ENUM,

        /** Expression which result is compound type. */
        COMPOUND
    };

    /**
     * Gets the evaluated type of the expression.
     *
     * @return Returns the type of the expression.
     */
    public ExpressionType getExprType()
    {
        return expressionType;
    }

    /**
     * Gets the evaluated Zserio type for the expression.
     *
     * @return Returns the Zserio type for the expression.
     */
    public ZserioType getExprZserioType()
    {
        return zserioType;
    }

    /**
     * Gets the evaluated identifier symbol object for the expression.
     *
     * @return Returns the identifier symbol object for the expression.
     */
    public Object getExprSymbolObject()
    {
        return symbolObject;
    }

    /**
     * Gets value for integer expression.
     *
     * @return Returns value for integer expression or null if expression is not integer or if value of integer
     *         expression is not possible to evaluate during compile time.
     */
    public BigInteger getIntegerValue()
    {
        return expressionIntegerValue.getValue();
    }

    /**
     * Gets upper bound for integer expression.
     *
     * @return Returns upper bound for integer expression or null if expression is not integer or if upper bound
     *         of integer expression is not possible to evaluate during compile time.
     */
    public BigInteger getIntegerUpperBound()
    {
        return expressionIntegerValue.getUpperBound();
    }

    /**
     * Gets needs BigInteger flag.
     *
     * @return Returns true if the expression contains value which needs BigInteger type.
     */
    public boolean needsBigInteger()
    {
        return expressionIntegerValue.needsBigInteger();
    }

    /**
     * Gets needs BigInteger casting to native flag.
     *
     * @return Returns true if the expression contains value which needs BigInteger type but it is assigned
     *                 to the native type.
     */
    public boolean needsBigIntegerCastingToNative()
    {
        return needsBigIntegerCastingToNative;
    }

    /**
     * Gets the first operand for the expression.
     *
     * This method should not be public but it is used by expression formatters at the moment.
     *
     * @return Returns the first operand.
     */
    public Expression op1()
    {
        return (Expression) getFirstChild();
    }

    /**
     * Gets the second operand for the expression.
     *
     * This method should not be public but it is used by expression formatters at the moment.
     *
     * @return Returns the second operand.
     */
    public Expression op2()
    {
        return (Expression) op1().getNextSibling();
    }

    /**
     * Gets the third operand for the expression.
     *
     * This method should not be public but it is used by expression formatters at the moment.
     *
     * @return Returns the third operand.
     */
    public Expression op3()
    {
        return (Expression) op2().getNextSibling();
    }

    /**
     * Gets all objects of given class referenced from the expression.
     *
     * @param clazz Class of which objects should be found.
     *
     * @return Set of objects of given class referenced from the expression.
     */
    public <T extends Object> Set<T> getReferencedSymbolObjects(Class<? extends T> clazz)
    {
        final Set<T> referencedSymbolObjects = new HashSet<T>();
        addReferencedSymbolObject(this, referencedSymbolObjects, clazz);

        return referencedSymbolObjects;
    }

    /**
     * Returns true if the expression requires the context of its owner.
     *
     * This is true if the expression references the compound type that contains the expression (i.e. a field,
     * a parameter) or if the expression contains compound function.
     *
     * @return Returns true if the expression needs reference to its owner.
     */
    public boolean requiresOwnerContext()
    {
        // check if expression contains a field
        if (!(getReferencedSymbolObjects(Field.class).isEmpty()))
            return true;

        // check if expression contains a parameter
        if (!(getReferencedSymbolObjects(Parameter.class).isEmpty()))
            return true;

        // check if expression contains a function type
        if (!(getReferencedSymbolObjects(FunctionType.class).isEmpty()))
            return true;

        return false;
    }

    /**
     * Checks if expression contains token "index".
     *
     * @return Returns true if this expression contains token "index".
     */
    public boolean containsIndex()
    {
        return containsOperand(this, ZserioParserTokenTypes.INDEX);
    }

    /**
     * Checks if expression contains ternary operator 'a ? b : c'.
     *
     * @return Returns true if this expression contains ternary operator.
     */
    public boolean containsTernaryOperator()
    {
        return containsOperand(this, ZserioParserTokenTypes.QUESTIONMARK);
    }

    /**
     * Checks if expression contains function call.
     *
     * @return Returns true if this expression contains function call.
     */
    public boolean containsFunctionCall()
    {
        return containsOperand(this, ZserioParserTokenTypes.FUNCTIONCALL);
    }

    /**
     * Checks if the expression contains explicit variable.
     *
     * @return Returns true if expression is explicit otherwise false.
     */
    public boolean isExplicitVariable()
    {
        return (getType() == ZserioParserTokenTypes.EXPLICIT);
    }

    /**
     * This method evaluates all expressions in tree which root is this expression.
     *
     * This method is called during pre-evaluation of expressions which are defined after the first usage.
     *
     * @param forceEvaluation Whether to force evaluation even if the expression is already evaluated.
     *
     * @throws ParserException Throws if expression is not valid.
     */
    public void evaluateTree(boolean forceEvaluation) throws ParserException
    {
        final ExpressionEvaluator expressionEvaluator = new ExpressionEvaluator();
        expressionEvaluator.setForceEvaluation(forceEvaluation);

        try
        {
            expressionEvaluator.expression(this);
        }
        catch (RecognitionException excpt)
        {
            throw new ParserException(this, excpt.getMessage());
        }
    }

    /**
     * This method evaluates one expression.
     *
     * Method fills up the following expression properties:
     *
     *   expressionType
     *   zserioType
     *   expressionIntegerValue
     *   unresolvedIdentifiers
     *   symbolObject
     *
     * It is supposed that the previous expression properties have been set to initialization values
     * (set by constructor).
     *
     * @param forceEvaluation Whether to force evaluation even if the expression is already evaluated.
     *
     * @throws ParserException Throws if expression is not valid.
     */
    public void evaluateOne(boolean forceEvaluation) throws ParserException
    {
        if (evaluationState == EvaluationState.IN_EVALUATION)
            throw new ParserException(this, "Cyclic dependency detected in expression evaluation!");

        if (forceEvaluation || evaluationState == EvaluationState.NOT_EVALUATED)
        {
            evaluationState = EvaluationState.IN_EVALUATION;

            switch (getType())
            {
                case ZserioParserTokenTypes.ID:
                    evaluateIdentifier(getText());
                    break;

                case ZserioParserTokenTypes.LPAREN:
                    final Expression operand = op1();
                    expressionType = operand.expressionType;
                    zserioType = operand.zserioType;
                    expressionIntegerValue = operand.expressionIntegerValue;
                    unresolvedIdentifiers = operand.unresolvedIdentifiers;
                    break;

                case ZserioParserTokenTypes.DOT:
                    evaluateDotExpression();
                    break;

                case ZserioParserTokenTypes.ARRAYELEM:
                    evaluateArrayElement();
                    break;

                case ZserioParserTokenTypes.QUESTIONMARK:
                    evaluateConditionalExpression();
                    break;

                case ZserioParserTokenTypes.INDEX:
                    evaluateIndexExpression();
                    break;

                case ZserioParserTokenTypes.LT:
                case ZserioParserTokenTypes.LE:
                case ZserioParserTokenTypes.GT:
                case ZserioParserTokenTypes.GE:
                case ZserioParserTokenTypes.EQ:
                case ZserioParserTokenTypes.NE:
                    evaluateRelationalExpression();
                    break;

                case ZserioParserTokenTypes.BANG:
                    evaluateNegationOperator();
                    break;

                case ZserioParserTokenTypes.UPLUS:
                    evaluateUnaryPlusMinus(false);
                    break;

                case ZserioParserTokenTypes.UMINUS:
                    evaluateUnaryPlusMinus(true);
                    break;

                case ZserioParserTokenTypes.PLUS:
                case ZserioParserTokenTypes.MINUS:
                case ZserioParserTokenTypes.MULTIPLY:
                case ZserioParserTokenTypes.DIVIDE:
                case ZserioParserTokenTypes.MODULO:
                    evaluateArithmeticExpression();
                    break;

                case ZserioParserTokenTypes.LSHIFT:
                case ZserioParserTokenTypes.RSHIFT:
                case ZserioParserTokenTypes.AND:
                case ZserioParserTokenTypes.OR:
                case ZserioParserTokenTypes.XOR:
                    evaluateBitExpression();
                    break;

                case ZserioParserTokenTypes.LOGICALAND:
                case ZserioParserTokenTypes.LOGICALOR:
                    evaluateLogicalExpression();
                    break;

                case ZserioParserTokenTypes.TILDE:
                    evaluateBitNotExpression();
                    break;

                case ZserioParserTokenTypes.LENGTHOF:
                    evaluateLengthOfOperator();
                    break;

                case ZserioParserTokenTypes.SUM:
                    evaluateSumOperator();
                    break;

                case ZserioParserTokenTypes.NUMBITS:
                    evaluateNumBitsOperator();
                    break;

                case ZserioParserTokenTypes.FUNCTIONCALL:
                    evaluateFunctionCallExpression();
                    break;

                case ZserioParserTokenTypes.EXPLICIT:
                    // do nothing
                    break;

                case ZserioParserTokenTypes.DECIMAL_LITERAL:
                    expressionType = ExpressionType.INTEGER;
                    expressionIntegerValue = new ExpressionIntegerValue(new BigInteger(getText()));
                    break;

                case ZserioParserTokenTypes.BINARY_LITERAL:
                    expressionType = ExpressionType.INTEGER;
                    final String binaryLiteral = getText();
                    final String strippedBinaryLiteral = binaryLiteral.substring(0, binaryLiteral.length() - 1);
                    expressionIntegerValue =
                            new ExpressionIntegerValue(new BigInteger(strippedBinaryLiteral, 2));
                    break;

                case ZserioParserTokenTypes.HEXADECIMAL_LITERAL:
                    expressionType = ExpressionType.INTEGER;
                    final String hexLiteral = getText();
                    final String strippedHexLiteral = hexLiteral.substring(2, hexLiteral.length());
                    expressionIntegerValue = new ExpressionIntegerValue(new BigInteger(strippedHexLiteral, 16));
                    break;

                case ZserioParserTokenTypes.OCTAL_LITERAL:
                    expressionType = ExpressionType.INTEGER;
                    expressionIntegerValue = new ExpressionIntegerValue(new BigInteger(getText(), 8));
                    break;

                case ZserioParserTokenTypes.BOOL_LITERAL:
                    expressionType = ExpressionType.BOOLEAN;
                    break;

                case ZserioParserTokenTypes.FLOAT_LITERAL:
                case ZserioParserTokenTypes.DOUBLE_LITERAL:
                    expressionType = ExpressionType.FLOAT;
                    break;

                case ZserioParserTokenTypes.STRING_LITERAL:
                    expressionType = ExpressionType.STRING;
                    break;

                default:
                    throw new ParserException(this, "Illegal expression type " + getType() + ".");
            }

            evaluationState = EvaluationState.EVALUATED;
        }
    }

    /**
     * This method checks of evaluation for expression.
     *
     * Method is necessary because of full qualified enumeration names. Example: wrong_package.enum_type.
     *
     * Expression "wrong_package" can be legaly unknown identifier during evaluation (we know nothing about
     * enum_type yet). Therefore the evaluation process must continue. Afterwards, expression "wrong_package"
     * will be checked during evaluation of dot expression. However if dot expression is not there, evaluation
     * of expression "wrong_package" will be succeeded even if the expression is not valid.
     *
     * @throws ParserException Throws if expression is not valid.
     */
    public void checkEvaluation() throws ParserException
    {
        if (getType() != ZserioParserTokenTypes.EXPLICIT && expressionType == ExpressionType.UNKNOWN)
          throw new ParserException(this, "Unresolved symbol in '" + getText() + "' expression!");
    }

    /**
     * This method propagates 'needs BigInteger' flag into already evaluated parts of expression.
     *
     * Method is necessary because Java expression formatter needs to have BigInteger flag set correctly for all
     * parts of expression.
     *
     * Example 1: 4 * 3 + uint64Value. Expression '4 * 3' will be evaluated before 'uint64Value'. Thus, literal
     * expressions '4' and '3' will not have set BigInteger flag. Such BigInteger flags can be set only
     * afterwards during evaluation of expression 'uint64Value'.
     *
     * Example 2: 4 * 3. Expression '4 * 3' will never have BigInteger flag set. Such BigInteger flags can be
     * set only after whole expression evaluation during checking of expression type in assignment. Therefore,
     * this method must be public.
     */
    public void propagateNeedsBigInteger()
    {
        if (expressionType == ExpressionType.INTEGER && !expressionIntegerValue.needsBigInteger())
        {
            expressionIntegerValue = new ExpressionIntegerValue(expressionIntegerValue.getValue(),
                    expressionIntegerValue.getLowerBound(), expressionIntegerValue.getUpperBound(), true);

            final Expression operand1 = op1();
            if (operand1 != null)
            {
                operand1.propagateNeedsBigInteger();
                final Expression operand2 = op2();
                if (operand2 != null)
                {
                    operand2.propagateNeedsBigInteger();
                    final Expression operand3 = op3();
                    if (operand3 != null)
                        operand3.propagateNeedsBigInteger();
                }
            }
        }
    }

    /**
     * Sets needs BigInteger casting flag.
     *
     * Method is necessary because Java expression formatter needs to know if expression which uses BigInteger
     * is assigned to the native type. In this case, casting to long native type is neccessary.
     *
     * Example:
     *
     * CastUInt64ToUInt8Expression
     * {
     *     uint64  uint64Value;
     *
     *     function uint8 uint8Value()
     *     {
     *         return uint64Value;
     *     }
     * };
     */
    public void setNeedsBigIntegerCastingNative()
    {
        needsBigIntegerCastingToNative = true;
    }

    @SuppressWarnings("unchecked")
    private <T extends Object> void addReferencedSymbolObject(Expression expression,
            Set<T> referencedObjectList, Class<? extends Object> elementClass)
    {
        final Object exprSymbolObject = expression.symbolObject;
        if (exprSymbolObject != null && elementClass.isInstance(exprSymbolObject))
            referencedObjectList.add((T)exprSymbolObject);

        final Expression operand1 = expression.op1();
        if (operand1 != null)
        {
            addReferencedSymbolObject(operand1, referencedObjectList, elementClass);
            final Expression operand2 = expression.op2();
            if (operand2 != null)
            {
                addReferencedSymbolObject(operand2, referencedObjectList, elementClass);
                final Expression operand3 = expression.op3();
                if (operand3 != null)
                    addReferencedSymbolObject(operand3, referencedObjectList, elementClass);
            }
        }
    }

    private boolean containsOperand(Expression expression, int operandTokenType)
    {
        if (expression.getType() == operandTokenType)
            return true;

        final Expression operand1 = expression.op1();
        if (operand1 != null)
        {
            if (containsOperand(operand1, operandTokenType))
                return true;

            final Expression operand2 = expression.op2();
            if (operand2 != null)
            {
                if (containsOperand(operand2, operandTokenType))
                    return true;

                final Expression operand3 = expression.op3();
                if (operand3 != null && containsOperand(operand3, operandTokenType))
                    return true;
            }
        }

        return false;
    }

    private void evaluateIdentifier(String identifier) throws ParserException
    {
        final Object identifierSymbol = scope.getSymbol(identifier);
        if (identifierSymbol == null)
        {
            // it still can be a type
            final ZserioType identifierType = scope.getPackage().getType(identifier);
            symbolObject = identifierType;
            if (identifierType == null)
            {
                // identifier not found, this can happened for structure field or package, we must wait for dot
                unresolvedIdentifiers.add(this);
            }
            else if (identifierType instanceof EnumType)
            {
                // enumeration type, we must wait for field and dot
                zserioType = (EnumType)identifierType;
            }
            else if (identifierType instanceof ConstType)
            {
                // constant type
                final ConstType constType = (ConstType)identifierType;
                evaluateExpressionType(constType.getConstType());
                final Expression constValueExpression = constType.getValueExpression();

                // call evaluation explicitly because this const does not have to be evaluated yet
                constValueExpression.evaluateTree(false);

                expressionIntegerValue = constValueExpression.expressionIntegerValue;

                // add this expression to 'Used-by' list for constant type (needed by documentation emitter)
                constType.setUsedByExpression(this);
            }
            else
            {
                throw new ParserException(this, "Type '" + identifier + "' (" +
                        identifierType.getClass() + ") is not allowed here!");
            }
        }
        else
        {
            symbolObject = identifierSymbol;
            if (identifierSymbol instanceof Field)
            {
                if (!isSymbolAvailable(identifier))
                    throw new ParserException(this, "Field '" + identifier + "' is not available!");
                evaluateExpressionType(((Field)identifierSymbol).getFieldType());
            }
            else if (identifierSymbol instanceof Parameter)
            {
                evaluateExpressionType(((Parameter)identifierSymbol).getParameterType());
            }
            else if (identifierSymbol instanceof FunctionType)
            {
                // function type, we must wait for "()"
                zserioType = (FunctionType)identifierSymbol;
            }
            else if (identifierSymbol instanceof EnumItem)
            {
                // enumeration item (this can happened for enum choices where enum is visible or for enum itself)
                final EnumItem enumItem = (EnumItem)identifierSymbol;
                final EnumType enumType = enumItem.getEnumType();
                ZserioType owner = scope.getOwner();

                // if this enumeration item is in own enum, leave it unresolved (we have problem with it because
                // such enumeration items cannot be evaluated yet)
                if (owner != enumType)
                    evaluateExpressionType(enumType);
            }
            else
            {
                throw new ParserException(this, "Symbol '" + identifier + "' (" +
                        identifierSymbol.getClass() + ") is not allowed here!");
            }
        }
    }

    private void evaluateExpressionType(ZserioType type) throws ParserException
    {
        // resolved instantiated type
        ZserioType resolvedType = type;
        if (resolvedType instanceof TypeInstantiation)
        {
            // call evaluation explicitly because this type instantiation does not have to be evaluated yet
            final TypeInstantiation typeInstantiation = (TypeInstantiation)resolvedType;
            typeInstantiation.evaluateBaseType();
            resolvedType = typeInstantiation.getReferencedType();
        }

        // resolve type reference
        resolvedType = TypeReference.resolveBaseType(resolvedType);

        if (resolvedType instanceof EnumType)
        {
            expressionType = ExpressionType.ENUM;
            if (symbolObject instanceof EnumItem)
            {
                // call evaluation explicitly because this enumeration item does not have to be evaluated yet
                final EnumItem enumItem = (EnumItem)symbolObject;
                enumItem.getEnumType().evaluateItemValues();

                // set integer value according to this enumeration item
                expressionIntegerValue = new ExpressionIntegerValue(enumItem.getValue());

                // add this expression to 'Used-by' list for enumeration item (needed by documentation emitter)
                enumItem.addUsedByExpression(this);
            }
        }
        else if (resolvedType instanceof IntegerType)
        {
            expressionType = ExpressionType.INTEGER;
            final IntegerType integerType = (IntegerType)resolvedType;
            if (resolvedType instanceof BitFieldType)
            {
                // call evaluation explicitly because this length does not have to be evaluated yet
                final BitFieldType bitFieldType = (BitFieldType)resolvedType;
                bitFieldType.evaluateBitSizes();
            }
            final BigInteger lowerBound = integerType.getLowerBound();
            final BigInteger upperBound = integerType.getUpperBound();
            if (lowerBound != null && upperBound != null)
                expressionIntegerValue = new ExpressionIntegerValue(lowerBound, upperBound);
        }
        else if (resolvedType instanceof FloatType)
        {
            expressionType = ExpressionType.FLOAT;
        }
        else if (resolvedType instanceof StringType)
        {
            expressionType = ExpressionType.STRING;
        }
        else if (resolvedType instanceof BooleanType)
        {
            expressionType = ExpressionType.BOOLEAN;
        }
        else if (resolvedType instanceof CompoundType)
        {
            expressionType = ExpressionType.COMPOUND;
        }
        else
        {
            expressionType = ExpressionType.UNKNOWN;
        }

        zserioType = resolvedType;
    }

    private void evaluateDotExpression() throws ParserException
    {
        final Expression op1 = op1();
        final Expression op2 = op2();
        if (op1.zserioType == null)
        {
            // left operand is unknown => it still can be a part of package
            evaluatePackageDotExpression(op1, op2);
        }
        else if (op1.zserioType instanceof EnumType)
        {
            // left operand is enumeration type
            evaluateEnumDotExpression(op1, op2);
        }
        else if (op1.zserioType instanceof CompoundType)
        {
            // left operand is compound type
            evaluateCompoundDotExpression(op1, op2);
        }
        else
        {
            throw new ParserException(op1, "Unexpected dot expression '" + op1.getText() + "'.");
        }
    }

    private void evaluatePackageDotExpression(Expression op1, Expression op2) throws ParserException
    {
        if (op2.zserioType == null)
        {
            // right operand is unknown as well => it still can be a part of long package
            unresolvedIdentifiers.addAll(op1.unresolvedIdentifiers);
            unresolvedIdentifiers.addAll(op2.unresolvedIdentifiers);
        }
        else if (op2.zserioType instanceof EnumType || op2.zserioType instanceof CompoundType)
        {
            // left operand is package and right operand in enum or compound
            final ZserioType op2ZserioType = op2.zserioType;
            final Package op2Package = op2ZserioType.getPackage();
            final List<String> packagePath = op2Package.getPackagePath();

            final List<String> op1UnresolvedIdentifiersPath =
                    new ArrayList<String>(op1.unresolvedIdentifiers.size());
            for (Expression unresolvedIdentifier : op1.unresolvedIdentifiers)
            {
                op1UnresolvedIdentifiersPath.add(unresolvedIdentifier.getText());
                unresolvedIdentifier.symbolObject = op2Package;
            }

            if (!packagePath.equals(op1UnresolvedIdentifiersPath))
            {
                // specified package is wrong
                final String wrongPackage = StringJoinUtil.joinStrings(op1UnresolvedIdentifiersPath, getText());
                throw new ParserException(op1, "Wrong package '" + wrongPackage + "' for type '" +
                        op2ZserioType.getName() + "'.");
            }

            zserioType = op2ZserioType;
        }
        else
        {
            // left operand is package and right operand is not enum or compound
            throw new ParserException(op2, "Unexpected dot expression '" + op2.getText() + "'.");
        }
    }

    private void evaluateEnumDotExpression(Expression op1, Expression op2) throws ParserException
    {
        final EnumType enumType = (EnumType)(op1.zserioType);
        final Scope enumScope = enumType.getScope();
        final String dotOperand = op2.getText();
        final Object enumSymbol = enumScope.getSymbol(dotOperand);
        if (!(enumSymbol instanceof EnumItem))
            throw new ParserException(this, "'" + dotOperand + "' undefined in enumeration '" +
                    enumType.getName() + "'.");

        // set unresolved symbol object for enumeration item as well (needed for formatters)
        op2.symbolObject = enumSymbol;
        // enumeration items can be already resolved because they are searched globally to support choices
        // with enumeration selector
        op2.zserioType = null;
        symbolObject = enumSymbol;
        evaluateExpressionType(enumType);
    }

    private void evaluateCompoundDotExpression(Expression op1, Expression op2) throws ParserException
    {
        final CompoundType compoundType = (CompoundType)(op1.zserioType);
        final Scope compoundScope = compoundType.getScope();
        final String dotOperand = op2.getText();
        final Object compoundSymbol = compoundScope.getSymbol(dotOperand);
        if (compoundSymbol == null)
            throw new ParserException(this, "'" + dotOperand + "' undefined in compound '" +
                    compoundType.getName() + "'.");

        // update unresolved symbol object for field as well (needed for formatters)
        op2.symbolObject = compoundSymbol;
        symbolObject = compoundSymbol;
        if (compoundSymbol instanceof Field)
        {
            evaluateExpressionType(((Field)compoundSymbol).getFieldType());
        }
        else if (compoundSymbol instanceof Parameter)
        {
            evaluateExpressionType(((Parameter)compoundSymbol).getParameterType());
        }
        else if (compoundSymbol instanceof FunctionType)
        {
            // function type, we must wait for "()"
            zserioType = (FunctionType)compoundSymbol;
        }
        else if (compoundSymbol instanceof CompoundType)
        {
            evaluateExpressionType((CompoundType)compoundSymbol);
        }
        else
        {
            throw new ParserException(this, "'" + dotOperand + "' undefined in compound '" +
                    compoundType.getName() + "'.");
        }
    }

    private void evaluateArrayElement() throws ParserException
    {
        final Expression op1 = op1();
        if (!(op1.zserioType instanceof ArrayType))
            throw new ParserException(op1, "'" + op1().getText() + "' is not an array.");

        final Expression op2 = op2();
        if (op2.expressionType != ExpressionType.INTEGER)
            throw new ParserException(op2, "Integer expression expected.");

        final ArrayType arrayType = (ArrayType)op1.zserioType;
        evaluateExpressionType(arrayType.getElementType());
    }

    private void evaluateConditionalExpression() throws ParserException
    {
        final Expression op1 = op1();
        if (op1.expressionType != ExpressionType.BOOLEAN)
            throw new ParserException(op1, "Boolean expression expected.");

        final Expression op2 = op2();
        final Expression op3 = op3();
        if (op2.expressionType == ExpressionType.UNKNOWN || op2.expressionType != op3.expressionType)
            throw new ParserException(this, "Incompatible expression types (" + op2.expressionType +
                    " != " + op3.expressionType + ").");

        expressionType = op2.expressionType;
        zserioType = op2.zserioType;
        if (expressionType == ExpressionType.INTEGER)
        {
            expressionIntegerValue = op2.expressionIntegerValue.conditional(op3.expressionIntegerValue);
            if (expressionIntegerValue.needsBigInteger())
            {
                op2.propagateNeedsBigInteger();
                op3.propagateNeedsBigInteger();
            }
        }
    }

    private void evaluateIndexExpression() throws ParserException
    {
        if (!allowIndex)
            throw new ParserException(this, "Index operator is not allowed in this context!");

        expressionType = ExpressionType.INTEGER;
        // array index has default expressionIntegerValue
    }

    private void evaluateRelationalExpression() throws ParserException
    {
        final Expression op1 = op1();
        final Expression op2 = op2();
        if (op1.expressionType == ExpressionType.UNKNOWN || op1.expressionType != op2.expressionType)
            throw new ParserException(this, "Incompatible expression types (" + op1.expressionType +
                    " != " + op2.expressionType + ").");

        final int tokenType = getType();
        if (op1.expressionType == ExpressionType.FLOAT &&
                tokenType != ZserioParserTokenTypes.LT && tokenType != ZserioParserTokenTypes.GT)
            throw new ParserException(this, "Equality operator is not allowed for floats.");

        if (op1.expressionType == ExpressionType.STRING &&
                tokenType != ZserioParserTokenTypes.EQ && tokenType != ZserioParserTokenTypes.NE)
            throw new ParserException(this,
                    "'Greater than' and 'less than' comparison is not allowed for strings.");

        if (op1.expressionType == ExpressionType.STRING)
            throw new ParserException(this, "String comparison is not implemented.");

        expressionType = ExpressionType.BOOLEAN;
        if (op1.expressionType == ExpressionType.INTEGER)
        {
            expressionIntegerValue = op1.expressionIntegerValue.relationalOperator(op2.expressionIntegerValue);
            if (expressionIntegerValue.needsBigInteger())
            {
                op1.propagateNeedsBigInteger();
                op2.propagateNeedsBigInteger();
            }
        }
    }

    private void evaluateNegationOperator() throws ParserException
    {
        final Expression op1 = op1();
        if (op1.expressionType != ExpressionType.BOOLEAN)
            throw new ParserException(this, "Boolean expression expected.");

        expressionType = ExpressionType.BOOLEAN;
    }

    private void evaluateUnaryPlusMinus(boolean isNegate) throws ParserException
    {
        final Expression op1 = op1();
        if (op1.expressionType != ExpressionType.INTEGER && op1.expressionType != ExpressionType.FLOAT)
            throw new ParserException(this, "Integer or float expressions expected.");

        if (op1.expressionType == ExpressionType.FLOAT)
        {
            expressionType = ExpressionType.FLOAT;
        }
        else
        {
            expressionType = ExpressionType.INTEGER;
            expressionIntegerValue = (isNegate) ? op1.expressionIntegerValue.negate() :
                op1.expressionIntegerValue;
        }
    }

    private void evaluateArithmeticExpression() throws ParserException
    {
        final Expression op1 = op1();
        final Expression op2 = op2();
        if (getType() == ZserioParserTokenTypes.PLUS && op1.expressionType == ExpressionType.STRING &&
                op2.expressionType == ExpressionType.STRING)
        {
            expressionType = ExpressionType.STRING;
        }
        else
        {
            if ( (op1.expressionType != ExpressionType.INTEGER && op1.expressionType != ExpressionType.FLOAT) ||
                 (op2.expressionType != ExpressionType.INTEGER && op2.expressionType != ExpressionType.FLOAT) )
                throw new ParserException(this, "Integer or float expressions expected.");

            if (op1.expressionType == ExpressionType.FLOAT || op2.expressionType == ExpressionType.FLOAT)
            {
                expressionType = ExpressionType.FLOAT;
            }
            else
            {
                expressionType = ExpressionType.INTEGER;
                switch (getType())
                {
                    case ZserioParserTokenTypes.PLUS:
                        expressionIntegerValue = op1.expressionIntegerValue.add(op2.expressionIntegerValue);
                        break;

                    case ZserioParserTokenTypes.MINUS:
                        expressionIntegerValue =
                            op1.expressionIntegerValue.subtract(op2.expressionIntegerValue);
                        break;

                    case ZserioParserTokenTypes.MULTIPLY:
                        expressionIntegerValue =
                            op1.expressionIntegerValue.multiply(op2.expressionIntegerValue);
                        break;

                    case ZserioParserTokenTypes.DIVIDE:
                        expressionIntegerValue = op1.expressionIntegerValue.divide(op2.expressionIntegerValue);
                        break;

                    case ZserioParserTokenTypes.MODULO:
                        expressionIntegerValue =
                            op1.expressionIntegerValue.remainder(op2.expressionIntegerValue);
                        break;

                    default:
                        throw new ParserException(this, "Illegal expression type " + getType() + ".");
                }

                if (expressionIntegerValue.needsBigInteger())
                {
                    op1.propagateNeedsBigInteger();
                    op2.propagateNeedsBigInteger();
                }
            }
        }
    }

    private void evaluateBitExpression() throws ParserException
    {
        final Expression op1 = op1();
        final Expression op2 = op2();
        if (op1.expressionType != ExpressionType.INTEGER || op2.expressionType != ExpressionType.INTEGER)
            throw new ParserException(this, "Integer expressions expected.");

        expressionType = ExpressionType.INTEGER;
        final int tokenType = getType();
        switch (tokenType)
        {
            case ZserioParserTokenTypes.LSHIFT:
                expressionIntegerValue = op1.expressionIntegerValue.shiftLeft(op2.expressionIntegerValue);
                break;

            case ZserioParserTokenTypes.RSHIFT:
                expressionIntegerValue = op1.expressionIntegerValue.shiftRight(op2.expressionIntegerValue);
                break;

            case ZserioParserTokenTypes.AND:
                expressionIntegerValue = op1.expressionIntegerValue.and(op2.expressionIntegerValue);
                break;

            case ZserioParserTokenTypes.OR:
                expressionIntegerValue = op1.expressionIntegerValue.or(op2.expressionIntegerValue);
                break;

            case ZserioParserTokenTypes.XOR:
                expressionIntegerValue = op1.expressionIntegerValue.xor(op2.expressionIntegerValue);
                break;

            default:
                throw new ParserException(this, "Illegal expression type " + getType() + ".");
        }

        if (tokenType != ZserioParserTokenTypes.LSHIFT && tokenType != ZserioParserTokenTypes.RSHIFT &&
                expressionIntegerValue.needsBigInteger())
        {
            op1.propagateNeedsBigInteger();
            op2.propagateNeedsBigInteger();
        }
    }

    private void evaluateLogicalExpression() throws ParserException
    {
        final Expression op1 = op1();
        final Expression op2 = op2();
        if (op1.expressionType != ExpressionType.BOOLEAN || op2.expressionType != ExpressionType.BOOLEAN)
            throw new ParserException(this, "Boolean expressions expected.");

        expressionType = ExpressionType.BOOLEAN;
    }

    private void evaluateBitNotExpression() throws ParserException
    {
        final Expression op1 = op1();
        if (op1.expressionType != ExpressionType.INTEGER)
            throw new ParserException(this, "Integer expression expected.");

        expressionType = ExpressionType.INTEGER;
        expressionIntegerValue = op1.expressionIntegerValue.not();
    }

    private void evaluateLengthOfOperator() throws ParserException
    {
        final Expression op1 = op1();
        if (!(op1.zserioType instanceof ArrayType))
            throw new ParserException(op1, "'" + op1().getText() + "' is not an array.");

        expressionType = ExpressionType.INTEGER;
        // length of result has default expressionIntegerValue
    }

    private void evaluateSumOperator() throws ParserException
    {
        final Expression op1 = op1();
        if (!(op1.zserioType instanceof ArrayType))
            throw new ParserException(op1, "'" + op1().getText() + "' is not an array.");

        final ArrayType arrayType = (ArrayType)op1.zserioType;
        evaluateExpressionType(arrayType.getElementType());
    }

    private void evaluateNumBitsOperator() throws ParserException
    {
        final Expression op1 = op1();
        if (op1.expressionType != ExpressionType.INTEGER)
            throw new ParserException(op1, "Integer expression expected.");

        expressionType = ExpressionType.INTEGER;
        expressionIntegerValue = op1.expressionIntegerValue.numbits();
    }

    private void evaluateFunctionCallExpression() throws ParserException
    {
        final Expression op1 = op1();
        if (!(op1.zserioType instanceof FunctionType))
        {
            throw new ParserException(op1, "'" + op1().getText() + "' is not a function.");
        }

        final FunctionType functionType = (FunctionType)op1.zserioType;
        final Expression functionResultExpression = functionType.getResultExpression();

        // function expression should know only symbols available on a place of the function call:
        // - if it's called within its owner object, it can see only symbols defined before the call,
        //   and for all other evaluations the symbols may remain restricted to the same set
        if (getScope().getOwner() == functionResultExpression.getScope().getOwner()) // called within the owner
            functionResultExpression.setAvailableSymbols(availableSymbols);

        try
        {
            functionResultExpression.evaluateTree(true);
        }
        catch (ParserException e)
        {
            throw new ParserException(functionResultExpression, e.getMessage() +
                    " In function '" + functionType.getName() + "' called from here:\n" +
                    getFileName() + ":" + getLine() + ":" + getColumn());
        }

        expressionType = functionResultExpression.expressionType;
        zserioType = functionResultExpression.zserioType;
        expressionIntegerValue = functionResultExpression.expressionIntegerValue;
    }

    private boolean isSymbolAvailable(String symbol)
    {
        return availableSymbols == null || availableSymbols.contains(symbol);
    }

    private enum EvaluationState
    {
        NOT_EVALUATED,
        IN_EVALUATION,
        EVALUATED
    };

    private EvaluationState evaluationState = EvaluationState.NOT_EVALUATED;

    private ExpressionType expressionType = ExpressionType.UNKNOWN;
    private ZserioType zserioType = null;
    private ExpressionIntegerValue expressionIntegerValue = new ExpressionIntegerValue();

    private List<Expression> unresolvedIdentifiers = new ArrayList<Expression>();

    private Object symbolObject = null;
    private boolean needsBigIntegerCastingToNative = false;
    private boolean allowIndex = false;

    private Scope scope = null;
    private Set<String> availableSymbols = null;

    private static final long serialVersionUID = -8971097647537214273L;
}

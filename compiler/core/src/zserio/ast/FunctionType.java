package zserio.ast;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import zserio.antlr.ZserioParserTokenTypes;
import zserio.antlr.util.BaseTokenAST;
import zserio.antlr.util.ParserException;
import zserio.tools.ZserioToolPrinter;

import antlr.collections.AST;

/**
 * AST node for function types.
 *
 * Function types are Zserio types as well.
 */
public class FunctionType extends TokenAST implements ZserioType
{
    /**
     * Default constructor.
     */
    public FunctionType()
    {
        usedTypeList = new ArrayList<ZserioType>();
        ZserioTypeContainer.add(this);
    }

    @Override
    public Package getPackage()
    {
        return pkg;
    }

    @Override
    public String getName()
    {
        return name;
    }

    @Override
    public Iterable<ZserioType> getUsedTypeList()
    {
        return usedTypeList;
    }

    @Override
    public void callVisitor(ZserioTypeVisitor visitor)
    {
        visitor.visitFunctionType(this);
    }

    /**
     * Sets package for the function type.
     *
     * This method is called by code generated by ANTLR using TypeEvaluator.g.
     *
     * @param pkg Package to set.
     */
    public void setPackage(Package pkg)
    {
        this.pkg = pkg;
    }

    /**
     * Gets unresolved function return Zserio type.
     *
     * @return Unresolved Zserio type defining the function return type.
     */
    public ZserioType getReturnType()
    {
        return returnType;
    }

    /**
     * Gets expression which represents function result.
     *
     * @return Function result expression.
     */
    public Expression getResultExpression()
    {
        return resultExpression;
    }

    @Override
    protected boolean evaluateChild(BaseTokenAST child) throws ParserException
    {
        switch (child.getType())
        {
        case ZserioParserTokenTypes.ID:
            name = child.getText();
            break;

        case ZserioParserTokenTypes.RETURN:
            final AST returnChild = child.getFirstChild();
            if (returnChild == null || !(returnChild instanceof Expression))
                return false;

            resultExpression = (Expression)returnChild;
            break;

        default:
            if (returnType != null || !(child instanceof ZserioType))
                return false;
            returnType = (ZserioType)child;
            break;
        }

        return true;
    }

    @Override
    protected void check() throws ParserException
    {
        // fill used type list
        final ZserioType resolvedTypeReference = TypeReference.resolveType(returnType);
        if (!ZserioTypeUtil.isBuiltIn(resolvedTypeReference))
            usedTypeList.add(resolvedTypeReference);

        // check result expression type
        final ZserioType resolvedReturnType = TypeReference.resolveBaseType(resolvedTypeReference);
        ExpressionUtil.checkExpressionType(resultExpression, resolvedReturnType);

        // check usage of unconditional optional fields (this is considered as a warning)
        if (!resultExpression.containsFunctionCall() && !resultExpression.containsTernaryOperator())
        {
            final Set<Field> referencedFields = resultExpression.getReferencedSymbolObjects(Field.class);
            for (Field referencedField : referencedFields)
            {
                if (referencedField.getIsOptional())
                    ZserioToolPrinter.printWarning(resultExpression, "Function '" + name + "' contains " +
                            "unconditional optional fields.");
            }
        }
    }

    private static final long serialVersionUID = -4573983414474344933L;

    private Package                 pkg;

    private ZserioType          returnType;
    private String                  name;
    private Expression              resultExpression;

    private List<ZserioType>    usedTypeList;
}

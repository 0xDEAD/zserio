package zserio.antlr.util;

import antlr.CommonASTWithHiddenTokens;
import antlr.Token;
import antlr.collections.AST;

/**
 * The AST token base class used for all grammars.
 *
 * This base class implements toString() method to show token type with text during AST tree visualization.
 *
 * Moreover, the class stores the file name, the line and column number of the token from which the AST token
 * has been created.
 *
 * Beside of that, the class provides conversion of token type to string.
 *
 * The method setImaginaryTokenPosition must be called from code generated by ANTLR for all AST tokens which
 * did not have any position in grammar file (which were created explicitly).
 */
public class BaseTokenAST extends CommonASTWithHiddenTokens
{
    /**
     * Constructor from token types class.
     *
     * @param tokenTypeDescriptor Token type descriptor class to get type properties like type name.
     */
    public BaseTokenAST(TokenTypeDescriptor tokenTypeDescriptor)
    {
        this.tokenTypeDescriptor = tokenTypeDescriptor;
        line = 0;
        column = 0;
    }

    /**
     * Constructor from token types class and lexer token.
     *
     * @param tokenTypeDescriptor Token type descriptor class to get type properties like type name.
     * @param lexerToken          Lexer token to construct from.
     */
    public BaseTokenAST(TokenTypeDescriptor tokenTypeDescriptor, Token lexerToken)
    {
        super(lexerToken);
        this.tokenTypeDescriptor = tokenTypeDescriptor;
    }

    /**
     * Overrides initialize method to store the token position.
     *
     * This method is called for imaginary tokens which do not have any associated lexer token.
     *
     * @param tokenType Token type to initialize.
     * @param text      Token text to initialize.
     */
    @Override
    public void initialize(int tokenType, String text)
    {
        super.initialize(tokenType, text);
        isImaginary = true;
    }

    /**
     * Overrides initialize method to store the token position from which this AST token is created.
     *
     * To store correct line and column of the source is necessary because the source position it is not stored
     * by AST token (only lexer type and text is stored).
     *
     * @param lexerToken Lexer token to initialize from.
     */
    @Override
    public void initialize(Token lexerToken)
    {
        super.initialize(lexerToken);
        line = lexerToken.getLine();
        column = lexerToken.getColumn();
        fileName = lexerToken.getFilename();
    }

    /**
     * Overrides initialize method to store the token position from which this AST token is created.
     *
     * @param token AST token to initialize from.
     */
    @Override
    public void initialize(AST token)
    {
        super.initialize(token);
        line = token.getLine();
        column = token.getColumn();
        fileName = (token instanceof BaseTokenAST) ? ((BaseTokenAST)token).getFileName() : null;
    }

    /**
     * Gets the line of the source where the token is located.
     *
     * The default implementation returns always 0.
     *
     * @return Line where the token is located.
     */
    @Override
    public int getLine()
    {
        if (isImaginary && line == 0)
        {
            // try to find the first child token to get position for imaginary tokens
            final BaseTokenAST child = (BaseTokenAST)getFirstChild();
            if (child != null)
                line = child.getLine();
        }

        return line;
    }

    /**
     * Gets the column of the source where the token is located.
     *
     * The default implementation returns always 0.
     *
     * @return Column where the token is located.
     */
    @Override
    public int getColumn()
    {
        if (isImaginary && column == 0)
        {
            // try to find the first child token to get position for imaginary tokens
            final BaseTokenAST child = (BaseTokenAST)getFirstChild();
            if (child != null)
                column = child.getColumn();
        }

        return column;
    }

    /**
     * Gets the name of the source file where the token is located.
     *
     * @return Name of the source file.
     */
    public String getFileName()
    {
        if (isImaginary && fileName == null)
        {
            // try to find the first child token to get position for imaginary tokens
            final BaseTokenAST child = (BaseTokenAST)getFirstChild();
            if (child != null)
                fileName = child.getFileName();
        }

        return fileName;
    }

    /**
     * Gets the token type name.
     *
     * @return The token type in string format.
     */
    public String getTokenTypeName()
    {
        final int tokenType = getType();
        final String typeName = tokenTypeDescriptor.getName(tokenType);
        if (typeName == null)
            return Integer.toString(tokenType);

        return typeName;
    }

    /**
     * Returns the AST token in string format used by '-showAst' switch.
     *
     * @return The AST token in string format.
     */
    @Override
    public String toString()
    {
        String result = getTokenTypeName();
        final String tokenText = getText();
        if (tokenText != null && !tokenText.isEmpty())
            result += " (" + getText() + ")";

        return result;
    }

    /**
     * Stores the file name, line and column number of the source from the given token.
     *
     * This method is called from ANTLR for imaginary tokens which do not have any children.
     *
     * @param nearestToken The nearest token to the imaginary from which to get the line and column number.
     */
    public void setImaginaryTokenPosition(BaseTokenAST nearestToken)
    {
        line = nearestToken.getLine();
        column = nearestToken.getColumn();
        fileName = nearestToken.getFileName();
    }

    /**
     * Gets imaginary flag.
     *
     * @return True if the token is imaginary, otherwise false.
     */
    public boolean isImaginary()
    {
        return isImaginary;
    }

    /**
     * Evaluates token and all its children.
     *
     * @throws ParserException Throws in case of invalid AST token.
     */
    public void evaluateAll() throws ParserException
    {
        if (!isEvaluated)
        {
            for (BaseTokenAST child = (BaseTokenAST)getFirstChild(); child != null;
                 child = (BaseTokenAST)child.getNextSibling())
            {
                if (!evaluateChild(child))
                    throw new ParserException(this, "Not expected child token of type " +
                            child.getTokenTypeName() + "!");

                child.evaluateAll();
            }

            evaluate();
            isEvaluated = true;
        }
    }

    /**
     * Evaluates one AST token child.
     *
     * This method should be implemented by inherited class.
     *
     * @param child AST token child to evaluate.
     *
     * @return Returns true in case of success or false if AST token child has not been recognized.
     *
     * @throws ParserException Throws in case of invalid AST token children.
     */
    protected boolean evaluateChild(BaseTokenAST child) throws ParserException
    {
        return true;
    }

    /**
     * Evaluates this token.
     *
     * This method should be implemented by inherited class.
     *
     * @throws ParserException Throws if evaluation fails.
     */
    protected void evaluate() throws ParserException
    {
    }

    private static final long           serialVersionUID = -1L;

    private final TokenTypeDescriptor   tokenTypeDescriptor;
    private int                         line;
    private int                         column;
    private String                      fileName;
    private boolean                     isEvaluated;
    private boolean                     isImaginary;
}

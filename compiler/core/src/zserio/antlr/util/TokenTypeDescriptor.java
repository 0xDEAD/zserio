package zserio.antlr.util;

import java.io.Serializable;
import java.lang.reflect.Field;

import java.util.HashMap;
import java.util.Map;

/**
 * The class to handle AST token type properties.
 *
 * ANTRL 2.0 does not provide directly in AST token classes the conversion of token type to its name. It does
 * not provide as well any possibility to check if the corresponded AST token is literal or not.
 * Because of that, this class contains a workaround implementation.
 *
 * To get token name, this class
 * - uses reflection to read all public members of generated ParserTokenTypes interface and
 * - fills hash map with read token type and token type name.
 *
 * To check if token is a keyword or not, this class uses _tokenNames public static member of generated
 * Parser implementation.
 */
public final class TokenTypeDescriptor implements Serializable
{
    /**
     * Constructor from parser class.
     *
     * @param parserClass Parser class generated by ANTLR 2.0.
     */
    public TokenTypeDescriptor(Class<?> parserClass)
    {
        tokenTypeToNameTable = new HashMap<Integer, String>();
        tokenTypeToIsKeywordFlagTable = new HashMap<Integer, Boolean>();

        // parser always implements the token types interface
        final Class<?>[] interfaces = parserClass.getInterfaces();
        if (interfaces.length != 0)
        {
            final Class<?> parserTokenTypesClass = interfaces[0];
            final Field[] tokenTypesClassFields = parserTokenTypesClass.getFields();
            for (Field tokenTypesClassField : tokenTypesClassFields)
            {
                try
                {
                    final int tokenType = tokenTypesClassField.getInt(parserTokenTypesClass);
                    final String tokenName = tokenTypesClassField.getName();
                    tokenTypeToNameTable.put(tokenType, tokenName);
                }
                catch (IllegalArgumentException exception)
                {}
                catch (IllegalAccessException exception)
                {}
            }
        }

        try
        {
            final Field _tokenNamesField = parserClass.getField("_tokenNames");
            processTokenNames((String[])_tokenNamesField.get(parserClass));
        }
        catch (NoSuchFieldException exception)
        {}
        catch (IllegalAccessException exception)
        {}
    }

    /**
     * Gets the token type name.
     *
     * @param tokenType AST token type to convert.
     *
     * @return AST token type in string or null in case of unknown token type.
     */
    public String getName(int tokenType)
    {
        return tokenTypeToNameTable.get(tokenType);
    }

    /**
     * Checks if given token is a keyword or not.
     *
     * @param tokenType AST token type to use.
     *
     * @return Returns true if given token is a keyword. It can return null if given token type is unknown.
     */
    public Boolean isKeyword(int tokenType)
    {
        return tokenTypeToIsKeywordFlagTable.get(tokenType);
    }

    /**
     * Sets token type names.
     *
     * This method accepts token type names (static member '_tokenNames') from the parser generated by ANTLR.
     * Token type names contains either token names or literals in quotes. This is used as a workaround to
     * distinguish literal tokens.
     *
     * @param tokenNames Token type names to set.
     */
    private void processTokenNames(String[] tokenNames)
    {
        int tokenType = 0;
        for (String tokenName : tokenNames)
        {
            final boolean isLiteral = (tokenName.startsWith("\"")) ? true : false;
            tokenTypeToIsKeywordFlagTable.put(tokenType, isLiteral);
            tokenType++;
        }
    }

    private static final long    serialVersionUID = -1L;

    private final Map<Integer, String> tokenTypeToNameTable;
    private final Map<Integer, Boolean> tokenTypeToIsKeywordFlagTable;
}
